// Class automatically generated by Dev-C++ New Class wizard
//#include "mtrand.h"
#include "population_sex_diff.h" // class's header file
#include "BRand.hpp"
#include <math.h>
#include <vector>
#include <iostream>
#include <cstdlib>
#include <boost/random/mersenne_twister.hpp>
#include <boost/random/poisson_distribution.hpp>
  using boost::poisson_distribution;
#include <boost/random/binomial_distribution.hpp>
  using boost::binomial_distribution;
#include <boost/random/variate_generator.hpp>
  using boost::variate_generator;

//Mersenne twister RNG from Boost
boost::mt19937 gent_b;

int boost_binom(double n, double p);

double population::s,population::h,population::hs;
double population_male::s,population_male::h,population_male::hs;

void population::initialize(double sel, double dom)
{
s=sel;
h=dom;
hs=h*s;
}


// class constructor
population::population(int N)
{
    alleleholders[0]=N;
    alleleholders[1]=0;
    alleleholders[2]=0;
    size=N;
}

void population_male::initialize(double sel, double dom)
{
s=sel;
h=dom;
hs=h*s;
}


// class constructor for males
population_male::population_male(int N)
{
    alleleholders[0]=N;
    alleleholders[1]=0;
    size=N;
}

void population::mutateup(int n)
{
     for (int i=0;i<n;i++)
     {
         if ((alleleholders[0]!=0)&&(BRand::Controller.nextOpened()>((0.5*alleleholders[1])/alleleholders[0])))
         {alleleholders[0]-=1;
         alleleholders[1]+=1;}
         else if (alleleholders[1]!=0)
         {alleleholders[1]-=1;
         alleleholders[2]+=1;}
     }

}

void population_male::mutateup(int n)
{
     for (int i=0;i<n;i++)
     {
         if ((alleleholders[0]!=0))
         {alleleholders[0]-=1;
         alleleholders[1]+=1;}
     }
}

void population::mutatedown(int n)
{
     for (int i=0;i<n;i++)
     {
         if ((alleleholders[2]!=0)&&(BRand::Controller.nextOpened()>((0.5*alleleholders[1])/alleleholders[2])))
         {alleleholders[2]-=1;
         alleleholders[1]+=1;}
         else if (alleleholders[1]!=0)
         {alleleholders[1]-=1;
         alleleholders[0]+=1;}
     }

}

void population_male::mutatedown(int n)
{
     for (int i=0;i<n;i++)
     {
       if ((alleleholders[1]!=0))
       {alleleholders[1]-=1;
       alleleholders[0]+=1;}
     }

}


void population::clear()
{
    alleleholders[0]=size;
    alleleholders[1]=0;
    alleleholders[2]=0;
}

void population_male::clear()
{
    alleleholders[0]=size;
    alleleholders[1]=0;

}


void population::fix()
{
    alleleholders[0]=0;
    alleleholders[1]=0;
    alleleholders[2]=size;
}

double population::prob()
{
       return (alleleholders[0]+(1.-hs)*alleleholders[1]*0.5)/(alleleholders[0]+(1.-hs)*alleleholders[1]+(1.-s)*alleleholders[2]);
}

void population::populate_from(population &p, double male_prob, int N)
{
    populate_from(p.prob(),male_prob,N);
}

void population::populate_from(double female_prob, double male_prob, int N)
{
    alleleholders[0]=0;
    alleleholders[1]=0;
    alleleholders[2]=0;
    if (N!=0) size=N;
    alleleholders[0] = boost_binom(size, male_prob*female_prob);
    alleleholders[2] = boost_binom(size-alleleholders[0],(1-female_prob)*(1-male_prob));
    alleleholders[1] = size - alleleholders[0] - alleleholders[2];
    /*
    if (prob<0.5) //drawing a binomial variate works faster when p<0.5
       {alleleholders[0]=binom(size,prob*prob);
       alleleholders[1]=binom(size-alleleholders[0],2*prob/(1+prob));
       alleleholders[2]=size-alleleholders[0]-alleleholders[1];
       }
    else  //drawing a binomial variate works faster when p<0.5
       {prob=1-prob;
       alleleholders[2]=binom(size,prob*prob);
       alleleholders[1]=binom(size-alleleholders[2],2*prob/(1+prob));
       alleleholders[0]=size-alleleholders[2]-alleleholders[1];
       }
       */
}

int population::allelenum()
{
return (alleleholders[1]+2*alleleholders[2]);
}

int population::binom(int n, double p)
{int x=0;
double y=0,c=log(1-p);
if (c==0)
   {//std::cout<<"c is zero!\n";
   return 0;}
while (1)
    {
    y+=ceil(log(BRand::Controller.nextOpened())/c);
    if (y>n) return x;
    x++;
    }
}

void population_male::fix()
{
    alleleholders[0]=0;
    alleleholders[1]=size;
}

double population_male::prob()
{
       return (alleleholders[0]/(alleleholders[0]+((1.-s)*alleleholders[1])));
}

void population_male::populate_from(population_male &p, double male_prob, int N)
{
    populate_from(p.prob(),male_prob,N);
}

void population_male::populate_from(double female_prob, double male_prob, int N)
{
    alleleholders[0]=0;
    alleleholders[1]=0;
    if (N!=0) size=N;
    alleleholders[0] = boost_binom(size, female_prob*male_prob);
    alleleholders[1] = size - alleleholders[0];
    /*
    if (prob<0.5) //drawing a binomial variate works faster when p<0.5
       {alleleholders[0]=binom(size,prob*prob);
       alleleholders[1]=binom(size-alleleholders[0],2*prob/(1+prob));

       }
    else  //drawing a binomial variate works faster when p<0.5
       {prob=1-prob;
       alleleholders[1]=binom(size,prob*prob);
       alleleholders[0]=binom(size-alleleholders[1],2*prob/(1+prob));

       }
       */
}

int population_male::allelenum()
{
return (alleleholders[1]);
}

int population_male::binom(int n, double p)
{int x=0;
double y=0,c=log(1-p);
if (c==0)
   {//std::cout<<"c is zero!\n";
   return 0;}
while (1)
    {
    y+=ceil(log(BRand::Controller.nextOpened())/c);
    if (y>n) return x;
    x++;
    }
}

int boost_binom(double n, double p) //Regular binomial random variate (Boost)

{
      boost::random::binomial_distribution<> dist(n, p);
      return dist(gent_b);
}

int population::choose_allele()
{double d=BRand::Controller.nextClosed();
if (d<(double(alleleholders[0])/size))
   return 0;
else if (d>(1-double(alleleholders[2])/size))
   return 2;
else
   return 1;
}

int population_male::choose_allele()
{double d=BRand::Controller.nextClosed();
if (d<(double(alleleholders[0])/size))
   return 0;
else if (d>(1-double(alleleholders[2])/size))
   return 2;
else
   return 1;

}

population::~population()
{
	std::cout<<"destructor called\n";

}

population_male::~population_male()
{
	std::cout<<"destructor called\n";

}
